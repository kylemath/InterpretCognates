{"role":"user","message":{"content":[{"type":"text","text":"<user_query>\nExplore the codebase to find all code related to the \"Phylogenetic Distance\" experiment. This is the fourth experiment in a scientific experiments section. Look for:\n\n1. The frontend component that renders the phylogenetic distance experiment card (likely in a React/frontend directory)\n2. The backend API endpoint that runs this experiment\n3. Any existing clustering or distance matrix computation code\n\nSearch thoroughly in all directories. Return the full file paths and relevant code sections for each finding.\n</user_query>"}]}}
{"role":"assistant","message":{"content":[{"type":"text","text":"Searching the codebase for \"Phylogenetic Distance\" experiment code. Starting with broad searches."}]}}
{"role":"assistant","message":{"content":[{"type":"text","text":"Reading the key files to get the complete code sections:"}]}}
{"role":"assistant","message":{"content":[{"type":"text","text":"Checking imports and helper functions used by the phylogenetic endpoint:"}]}}
{"role":"assistant","message":{"content":[{"type":"text","text":"## Findings: Phylogenetic Distance Experiment Code\n\n### 1. Frontend Components\n\n#### Main Experiment Card (4th experiment)\n**File:** `/Users/kylemathewson/InterpretCognates/backend/app/static/index.html`\n\n```128:133:backend/app/static/index.html\n          <div class=\"experimentCard\">\n            <h3>Phylogenetic Distance</h3>\n            <p>Compute embedding distance matrix across 40 languages over Swadesh vocabulary — preparation for Mantel test against ASJP.</p>\n            <button id=\"runPhyloBtn\" class=\"experimentBtn\">Run Experiment</button>\n            <div id=\"phyloResult\" class=\"experimentResult\"></div>\n          </div>\n```\n\n#### Frontend JavaScript Handler (Main App)\n**File:** `/Users/kylemathewson/InterpretCognates/backend/app/static/app.js`\n\n```896:940:backend/app/static/app.js\n// --- Phylogenetic ---\nconst runPhyloBtn = document.getElementById(\"runPhyloBtn\");\nif (runPhyloBtn) {\n  runPhyloBtn.addEventListener(\"click\", async () => {\n    const resultEl = document.getElementById(\"phyloResult\");\n    runPhyloBtn.disabled = true;\n    runPhyloBtn.textContent = \"Running...\";\n    showExperimentLoading(resultEl, \"Computing embedding distances across Swadesh vocabulary...\");\n    try {\n      const resp = await fetch(\"/api/experiment/phylogenetic\", { method: \"POST\" });\n      if (!resp.ok) throw new Error(`API error ${resp.status}`);\n      const data = await resp.json();\n      renderPhyloResult(resultEl, data);\n    } catch (err) {\n      showExperimentError(resultEl, err.message);\n    } finally {\n      runPhyloBtn.disabled = false;\n      runPhyloBtn.textContent = \"Run Experiment\";\n    }\n  });\n}\n\nfunction renderPhyloResult(el, data) {\n  const chartId = \"phylo-heatmap\";\n  const langNames = data.languages.map((code) => langName(code));\n\n  let html = `<p><strong>${data.num_languages}</strong> languages — embedding distance matrix over Swadesh vocabulary</p>`;\n  html += `<div id=\"${chartId}\" class=\"chart\"></div>`;\n  el.innerHTML = html;\n\n  Plotly.newPlot(chartId, [{\n    z: data.embedding_distance_matrix,\n    x: langNames,\n    y: langNames,\n    type: \"heatmap\",\n    colorscale: \"Viridis\",\n    hovertemplate: \"<b>%{y}</b> × <b>%{x}</b><br>distance: %{z:.4f}<extra></extra>\",\n    colorbar: { title: \"Cosine<br>distance\", thickness: 14, len: 0.5 },\n  }], {\n    margin: { l: 120, r: 20, t: 10, b: 120 },\n    height: 600,\n    xaxis: { tickangle: -45, tickfont: { size: 10 } },\n    yaxis: { tickfont: { size: 10 }, autorange: \"reversed\" },\n  }, { responsive: true });\n}\n```\n\n#### Validation Page Component\n**File:** `/Users/kylemathewson/InterpretCognates/backend/app/static/validation.html`\n\n```122:142:backend/app/static/validation.html\n      <!-- Panel 5: Phylogenetic Distance -->\n      <section class=\"experimentCard\" id=\"panel-phylogenetic\">\n        <div class=\"cardHeader\">\n          <span class=\"panelNumber\">5</span>\n          <div>\n            <h2>Phylogenetic Distance (Preparation)</h2>\n            <p class=\"cardDesc\">\n              Preparation for the Mantel test: embedding distance matrix across\n              40 languages over Swadesh vocabulary. The full test requires ASJP\n              phonetic distance data (not yet integrated).\n            </p>\n          </div>\n        </div>\n        <div class=\"cardActions\">\n          <button class=\"runBtn\" id=\"btn-phylogenetic\" onclick=\"runPhylogenetic()\">\n            Run Test\n          </button>\n          <span class=\"timeEstimate\">~2–5 min</span>\n        </div>\n        <div class=\"resultsArea\" id=\"results-phylogenetic\"></div>\n      </section>\n```\n\n#### Validation JavaScript Handler\n**File:** `/Users/kylemathewson/InterpretCognates/backend/app/static/validation.js`\n\n```428:482:backend/app/static/validation.js\n// ─── Panel 5: Phylogenetic Distance ─────────────────────────────────────────\n\nasync function runPhylogenetic() {\n  disableBtn(\"btn-phylogenetic\");\n  showLoading(\"phylogenetic\");\n\n  try {\n    const resp = await fetch(\"/api/experiment/phylogenetic\", { method: \"POST\" });\n    if (!resp.ok) throw new Error(`API returned ${resp.status}`);\n    const data = await resp.json();\n    renderPhylogenetic(data);\n  } catch (err) {\n    showError(\"phylogenetic\", err.message);\n  } finally {\n    resetBtn(\"btn-phylogenetic\", \"Re-run Test\");\n  }\n}\n\nfunction renderPhylogenetic(data) {\n  const el = document.getElementById(\"results-phylogenetic\");\n  el.innerHTML = \"\";\n\n  const labels = data.languages.map(langName);\n\n  el.innerHTML = `\n    <div class=\"statRow\">\n      ${statBadge(\"Languages\", data.num_languages)}\n    </div>\n    <p class=\"resultsSectionTitle\">Embedding Distance Matrix</p>\n    <div class=\"chartContainer\" id=\"chart-phylo-heatmap\"></div>\n    <div class=\"noteBox\">\n      This heatmap shows pairwise embedding distances across ${data.num_languages}\n      languages, computed over Swadesh vocabulary. To complete the Mantel test,\n      ASJP phonetic distance data must be integrated as a second distance\n      matrix for correlation analysis.\n    </div>`;\n\n  Plotly.newPlot(\"chart-phylo-heatmap\", [{\n    z: data.embedding_distance_matrix,\n    x: labels, y: labels,\n    type: \"heatmap\",\n    colorscale: [\n      [0, \"#eef2ff\"], [0.25, \"#a5b4fc\"], [0.5, \"#6366f1\"],\n      [0.75, \"#4338ca\"], [1, \"#1e1b4b\"]\n    ],\n    hovertemplate: \"<b>%{x}</b> ↔ <b>%{y}</b><br>Distance: %{z:.4f}<extra></extra>\",\n    colorbar: { title: { text: \"Distance\", font: { size: 11 } }, thickness: 14 },\n  }], plotlyLayout({\n    height: Math.max(600, data.num_languages * 18),\n    width: Math.max(700, data.num_languages * 18),\n    margin: { l: 110, r: 40, t: 20, b: 110 },\n    xaxis: { tickangle: -45, tickfont: { size: 9 }, side: \"bottom\" },\n    yaxis: { tickfont: { size: 9 }, autorange: \"reversed\" },\n  }), { responsive: true });\n}\n```\n\n### 2. Backend API Endpoint\n\n**File:** `/Users/kylemathewson/InterpretCognates/backend/app/main.py`\n\n```236:273:backend/app/main.py\n# ---------------------------------------------------------------------------\n# Phylogenetic correlation endpoint (Task 6)\n# ---------------------------------------------------------------------------\n\n@app.post(\"/api/experiment/phylogenetic\")\ndef experiment_phylogenetic() -> dict:\n    corpus = load_swadesh_corpus()\n    languages = [lang[\"code\"] for lang in corpus[\"languages\"]]\n    concepts = corpus[\"concepts\"]\n\n    concept_embeddings: dict[str, dict[str, np.ndarray]] = {}\n    all_texts = []\n    all_langs = []\n    all_keys = []\n\n    for concept_name, translations in concepts.items():\n        for lang_code in languages:\n            word = translations.get(lang_code)\n            if word:\n                all_texts.append(word)\n                all_langs.append(lang_code)\n                all_keys.append((concept_name, lang_code))\n\n    vectors = embed_text_batch(all_texts, all_langs)\n\n    for (concept_name, lang_code), vec in zip(all_keys, vectors):\n        if concept_name not in concept_embeddings:\n            concept_embeddings[concept_name] = {}\n        concept_embeddings[concept_name][lang_code] = vec\n\n    embedding_dist = compute_swadesh_embedding_distances(concept_embeddings, languages)\n\n    return {\n        \"num_languages\": len(languages),\n        \"languages\": languages,\n        \"embedding_distance_matrix\": embedding_dist.tolist(),\n        \"note\": \"To complete phylogenetic test, supply ASJP distance matrix and call /api/experiment/mantel\",\n    }\n```\n\n### 3. Distance Matrix Computation Code\n\n**File:** `/Users/kylemathewson/InterpretCognates/backend/app/benchmarks.py`\n\n#### Cosine Distance Matrix Function\n```121:127:backend/app/benchmarks.py\ndef cosine_distance_matrix(vectors: list[np.ndarray]) -> np.ndarray:\n    \"\"\"Compute pairwise cosine distance (1 - cosine_similarity) matrix.\"\"\"\n    array = np.array(vectors)\n    norms = np.linalg.norm(array, axis=1, keepdims=True)\n    normalized = array / np.clip(norms, 1e-8, None)\n    similarity = normalized @ normalized.T\n    return 1.0 - similarity\n```\n\n#### Swadesh Embedding Distance Computation\n```130:159:backend/app/benchmarks.py\ndef compute_swadesh_embedding_distances(\n    concept_embeddings: dict[str, dict[str, np.ndarray]],\n    languages: list[str],\n) -> np.ndarray:\n    \"\"\"Compute mean cosine distance across Swadesh concepts for each language pair.\n\n    concept_embeddings: {concept_name: {lang_code: embedding_vector}}\n    languages: ordered list of NLLB language codes\n\n    Returns: N×N distance matrix.\n    \"\"\"\n    n = len(languages)\n    lang_idx = {lang: i for i, lang in enumerate(languages)}\n    dist_sum = np.zeros((n, n))\n    count = np.zeros((n, n))\n\n    for concept, lang_vecs in concept_embeddings.items():\n        available = [lang for lang in languages if lang in lang_vecs]\n        if len(available) < 2:\n            continue\n        vecs = [lang_vecs[lang] for lang in available]\n        cos_dist = cosine_distance_matrix(vecs)\n        for ai, lang_a in enumerate(available):\n            for bi, lang_b in enumerate(available):\n                i, j = lang_idx[lang_a], lang_idx[lang_b]\n                dist_sum[i, j] += cos_dist[ai, bi]\n                count[i, j] += 1\n\n    count = np.clip(count, 1, None)\n    return dist_sum / count\n```\n\n#### Mantel Test Function (for future ASJP integration)\n```88:118:backend/app/benchmarks.py\ndef mantel_test(\n    dist_a: np.ndarray, dist_b: np.ndarray, permutations: int = 9999\n) -> dict[str, float]:\n    \"\"\"Mantel test: correlation between two distance matrices.\n\n    Uses Spearman rank correlation on the upper triangle, with a\n    permutation test for significance.\n\n    Returns dict with keys: rho, p_value, permutations.\n    \"\"\"\n    n = dist_a.shape[0]\n    assert dist_a.shape == dist_b.shape == (n, n), \"Distance matrices must be square and same size\"\n\n    idx_upper = [(i, j) for i in range(n) for j in range(i + 1, n)]\n    a_flat = np.array([dist_a[i, j] for i, j in idx_upper])\n    b_flat = np.array([dist_b[i, j] for i, j in idx_upper])\n\n    rho_obs, _ = spearmanr(a_flat, b_flat)\n\n    count_ge = 0\n    rng = np.random.default_rng(42)\n    for _ in range(permutations):\n        perm = rng.permutation(n)\n        b_perm = dist_b[np.ix_(perm, perm)]\n        b_perm_flat = np.array([b_perm[i, j] for i, j in idx_upper])\n        rho_perm, _ = spearmanr(a_flat, b_perm_flat)\n        if rho_perm >= rho_obs:\n            count_ge += 1\n\n    p_value = (count_ge + 1) / (permutations + 1)\n    return {\"rho\": float(rho_obs), \"p_value\": float(p_value), \"permutations\": permutations}\n```\n\n### Summary\n\n- Frontend: Two implementations (main app and validation page) render the experiment card and handle API calls, displaying results as Plotly heatmaps.\n- Backend API: `/api/experiment/phylogenetic` endpoint computes embedding distances over Swadesh vocabulary.\n- Distance computation: Functions in `benchmarks.py` compute cosine distance matrices and aggregate them across concepts. A Mantel test function exists but is not yet integrated with ASJP data.\n\nThe experiment is functional for computing embedding distance matrices; ASJP integration for the Mantel test is pending."}]}}